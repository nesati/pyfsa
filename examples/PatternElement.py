""" module PatternElement --- token tests"""class PatternElement:    fieldNames = ('tag', 'stem', 'token', 'pred')    isPatternElement = 1    isComplexPatternElement = 0        def __init__(self, tag=[], stem=[], token=[], pred=[], quant=None):        for name in self.fieldNames:            value = list(locals()[name])            value.sort()            setattr(self, name, tuple(value))        self.quant = quant        def isExclusiveField(self, fieldName):        """These fields of the item being tested can only have one value. """        return fieldName in ('tag', 'stem', 'token')        def __cmp__(self, other):        # this function ends up being called huge numbers of times during FSA        # construction, and unrolling the loop as here speeds it up        # substantially over using fieldNames        return cmp(type(self), type(other)) or cmp(self.__class__, other.__class__) \            or cmp(self.tag, other.tag) or cmp(self.stem, other.stem) \            or cmp(self.token, other.token) or cmp(self.pred, other.pred)    def __hash__(self):        if hasattr(self, '_cachedHash'):            return self._cachedHash        value = hash(self.quant)        for name in self.fieldNames:            value = value ^ hash(getattr(self, name))        self._cachedHash = value        return value    def match(self, pt):        """Return 1 if self matches pt, a PreTerminal. Return 0        otherwise. This is a basic match and does not take        account of quantifiers, it just checks for token, stem        and tag values. The list values on self.token etc are        interpreted as disjunctions if the list is not empty and        as fully unspecified if the list is empty. There is no        negation."""        if self.token and pt.token not in self.token: return 0        if self.stem and pt.stem not in self.stem: return 0        if self.tag and pt.tag not in self.tag: return 0        if self.pred and not filter(lambda p, pt=pt:p(pt), self.pred): return 0        return 1        def matches(self, pt):        return self.match(pt)        def withoutQuantifier(self):        if self.quant:            return PatternElement(tag=self.tag, stem=self.stem, token=self.token, pred=self.pred)        return self        def isSingleton(self):        return not self.quant    def isKleeneStar(self):        return self.quant == '*'    def isKleenePlus(self):        return self.quant == '+'    def isOptional(self):        return self.quant == '?'    def asHtmlString(self):        string = '<b>[</b> '        if self.token: string = string + 'token=' + `self.token` + ' '        if self.stem: string = string + 'stem=' + `self.stem` + ' '        if self.tag: string = string + 'tag=' + `self.tag` + ' '        if self.pred: string = string + 'pred=' + `self.pred` + ' '        string = string + ' <b>]</b>'        if self.quant: string = string + self.quant        return string    def __repr__(self, negated=0):        """        >>> PatternElement(tag=['NN'])        NN        >>> PatternElement(tag=['NN', 'NNP'])        NN|NNP        >>> PatternElement(tag=['NN'], quant='*')        NN*        >>> PatternElement(tag=['NN', 'NNP'], quant='*')        (NN|NNP)*        >>> PatternElement(token=['of'])        'of'        >>> PatternElement(token=['of', 'on'])        'of' | 'on'        >>> PatternElement(stem=['of'])        stem='of'        >>> PatternElement(stem=['of', 'on'])        stem in ('of', 'on')        >>> PatternElement(tag=['NN'],token=['protein'])        'protein' & NN        >>> PatternElement()        ANY        """        import string        tags = collapseAbbreviations(list(self.tag), 'tag')        tokens = collapseAbbreviations(self.token, 'token')        stems = collapseAbbreviations(self.stem, 'stem')        preds = collapseAbbreviations(self.pred, 'pred')        s = string.join(map(repr, tokens), ' | ')        if self.tag:            def tagStr(tag, prefix=negated and '~' or ''):                import string                s = str(tag)                tagChars = string.letters + string.digits + '#_-'                if filter(lambda c, tagChars=tagChars:c not in tagChars, s):                    s = '#' + s                return prefix + s            s = s + (s and ' & ' or '') + string.join(map(tagStr, tags), negated and ' & ' or '|')         if self.stem:            if s: s = s + ' & '            def stemStr(stem, originalStems=self.stem):                if stem in originalStems:                    return `stem`                else:                    return str(stem)            notStr = negated and 'not ' or ''            if len(stems) == 1:                stem = stems[0]                if stem in self.stem:                    eqOp = negated and ' != ' or '='                    s = s + 'stem' + eqOp + stemStr(stem)                else:                    s = s + 'stem ' + notStr + 'in ' + stemStr(stem)            else:                s = s + 'stem ' + notStr + 'in (' + string.join(map(stemStr, stems), ', ') + ')'        if self.pred:            def predName(pred, prefix=negated and '~' or ''):                try:                    return prefix + pred.__name__ + '()'                except AttributeError:                    return prefix + pred + '()'            s = s + (s and ' & ' or '') + string.join(map(predName, preds), negated and ' & ' or ' | ')         if not s:            s = 'ANY'        if self.quant:            if ' ' in s or '|' in s or '&' in s:                s = '(' + s + ')'            s = s + self.quant        return s        def isUnconditional(self):        return not self.tag and not self.stem and not self.token and not self.pred        def terms(self):        testers = []        for fieldName in self.fieldNames:            value = getattr(self, fieldName)            if value:                testers.append(apply(PatternElement, (), {fieldName: value}))        return testers        def build(self, terms):        return combinePatternTerms(terms)        def complement(self):        """        >>> PatternElement(tag=['a', 'b']).complement().complement() == PatternElement(tag=['a', 'b'])        1        >>> PatternElement(tag=['a'], stem=['b']).complement()        [~a, ~stem='b']        >>> PatternElement(tag=['a', 'b']).complement()        [~a, ~a & ~stem='b']        """        complements = self.complements()        return len(complements) == 1 and complements[0] or complements    def complements(self):        """Returns the complements as a list, so that callers don't have to normalize it."""        firstKey = None        remainder = {}        for fieldName in self.fieldNames:            value = getattr(self, fieldName)            if value:                if not firstKey:                    firstKey, firstValue = fieldName, value                else:                    remainder[fieldName] = value        if firstKey:            firstTester = apply(PatternElement, (), {firstKey: firstValue})            firstComplement = ComplexPatternElement(None, firstTester)            complements = [firstComplement]            if remainder.keys():                for complement in apply(PatternElement, (), remainder).complements():                    complements.append(firstTester.intersection(complement))            return complements        else:            return []        def intersection(self, other):        """        >>> PatternElement(tag=['a', 'b']).intersection(PatternElement(tag=['b', 'c'])) == PatternElement(tag=['b'])        1        >>> PatternElement(tag=['a']).intersection(PatternElement(tag=['b']))        """        if not getattr(other, 'isPatternElement', 0) or other.isComplexPatternElement:            return other.intersection(self)        if self.isUnconditional():            return other        if other.isUnconditional():            return self        #if self == other: return self        fields = {}        for name in self.fieldNames:            a, b = getattr(self, name), getattr(other, name)            if a and b:                if name == 'pred':                    c = listUnion(a, b)                else:                    c = listIntersection(a, b)                if not c:                    return None            else:                c = a or b            fields[name] = c        fields = simplifyFieldValues(fields)        if not fields:            return None        return apply(PatternElement, (), fields)class ComplexPatternElement :    """A ComplexPatternElement represents the intersection of a PatternTest,    with the complements of a set of PatternTests. A ComplexPatternElement has    a required PatternTest, and an excluded PatternTest. It's true of a token    if the required test is true, and each field of the excluded test is false.    (Note that it's just using the excluded object as a container for its field    tests, without preserving its semantics --- ALL the tests in the excluded    object must be false for the ComplexPatternElement to test true, whereas    the excluded object itself will test false if ANY of its tests are    false."""    TRACE_INTERSECTIONS = 0    isPatternElement = 1    isComplexPatternElement = 1        def __init__(self, required, excluded):        assert not excluded.isUnconditional(), "ComplexPatternElement is really a PatternElement"        self.required = required or PatternElement()        self.excluded = excluded        self.excludedTests = self.excluded.terms()        def __cmp__(self, other):        return cmp(type(self), type(other)) or cmp(self.__class__, other.__class__) or cmp(self.required, other.required) \            or cmp(self.excluded, other.excluded)        def __hash__(self):        return hash(self.required) ^ hash(self.excluded)        def __repr__(self):        str = ''        if not self.required.isUnconditional():            str = `self.required`        for tester in self.excludedTests:            testStr = tester.__repr__(negated=1)            #if filter(lambda c:c in ' &|', testStr):            #   testStr = '(' + testStr + ')'            str = str + (str and ' & ') + testStr        return str        def isUnconditional(self):        return 0        def match(self, pt):        if not self.required.match(pt):            return 0        for tester in self.excludedTests:            if tester.match(pt):                return 0        return 1        def matches(self, pt):        return self.match(pt)        def terms(self):        return self.required.terms() + map(lambda term:term.complement(), self.excludedTests)        def build(self, terms):        return combinePatternTerms(terms)        def complements(self):        complements = self.required.complements()        running = self.required        for tester in self.excludedTests:            complements.append(running.intersection(tester))            running = running.intersection(tester.complement())         return complements        def complement(self):        """        >>> PatternElement(tag=['b']).complement()        ~b        """        complements = self.complements()        if len(complements) == 1:            return complements[0]        else:            return complements        def intersection(self, other):        """        >>> PatternElement(tag=['a', 'b']).intersection(PatternElement(tag=['a']))        a        >>> PatternElement(tag=['a', 'b']).intersection(PatternElement(tag=['a']).complement())        b        >>> PatternElement(tag=['a', 'b']).intersection(PatternElement(tag=['a', 'b']).complement())        >>> PatternElement(tag=['a']).intersection(PatternElement(tag=['b']).complement())        a & ~b        >>> PatternElement(tag=['a']).complement().intersection(PatternElement(tag=['b']).complement())        ~(a|b)        >>> PatternElement(tag=['a']).complement().intersection(PatternElement(token=['b']).complement())        ~('b' & a)        >>> ComplexPatternElement(PatternElement(tag=['a'], token=['b']), PatternElement(tag=['c'], token=['d'])).complement()        ['d' & c, ~a, ~'b']        >>> ComplexPatternElement(PatternElement(tag=['a']), PatternElement(tag=['b'])).intersection(PatternElement(tag=['c']))        """        if not getattr(other, 'isPatternElement', 0):            return other.intersection(self)        try:            cache = self._intersectionCache        except AttributeError:            cache = self._intersectionCache = {}        requiredFieldValues = {}        excludedFieldValues = {}        otherRequired, otherExcluded = other, None        if other.isComplexPatternElement:            otherRequired, otherExcluded = other.required,other.excluded        for name in self.required.fieldNames:            these = getattr(self.required, name)            those = getattr(otherRequired, name)            if these and those:                required = listIntersection(these, those)            else:                required = these or those            excluded = getattr(self.excluded, name)            if otherExcluded:                excluded = listUnion(excluded, getattr(otherExcluded, name))            required = listDifference(required, excluded)            if self.TRACE_INTERSECTIONS:                print name, required, excluded            if not required and (these or those):                return None            if required and self.required.isExclusiveField(name):                excluded = ()            requiredFieldValues[name] = required            excludedFieldValues[name] = excluded        requiredFieldValues = simplifyFieldValues(requiredFieldValues)        if not requiredFieldValues:            return None        required = apply(PatternElement, (), requiredFieldValues)        excluded = apply(PatternElement, (), excludedFieldValues)        if excluded.isUnconditional():            cache[other] = required            return required        else:            result = ComplexPatternElement(required, excluded)            cache[other] = result            return result## PatternTest construction#def combinePatternTerms(terms):    requiredInitargs = {}    excludedInitargs = {}    for term in terms:        if getattr(term, 'isComplexPatternElement', 0):            initargs, basis = excludedInitargs, term.excluded        else:            initargs, basis = requiredInitargs, term        for fieldName in basis.fieldNames:            value = getattr(basis, fieldName)            if value:                assert not initargs.get(fieldName)                initargs[fieldName] = value    required = apply(PatternElement, (), requiredInitargs)    excluded = apply(PatternElement, (), excludedInitargs)    if excluded.isUnconditional():        return required    else:        return ComplexPatternElement(required, excluded)## PatternTest simplification#POSSIBLE_STEM_TAGS = {}POSSIBLE_STEM_SET_TAGS = {}def possibleStemTags(stem):    from types import ListType    tags = POSSIBLE_STEM_TAGS.get(stem)    if tags:        return tags    from stemmer import unstemToken    from ourtagger import tag    from htagger import possibleTags    tags = []    for token in unstemToken(stem):        tags = listUnion(tags, possibleTags(tag([token])[0]))    POSSIBLE_STEM_SET_TAGS[stem] = tags    return tagsdef possibleStemSetTags(stems):    from types import ListType    if type(stems) == ListType:        stems = tuple(stems)    tags = POSSIBLE_STEM_SET_TAGS.get(stems)    if tags:        return tags    tags = []    for stem in stems:        tags = listUnion(tags, possibleStemTags(stem))    POSSIBLE_STEM_SET_TAGS[stems] = tags    return tagsdef simplifyFieldValues(fields):    tokens = fields.get('token')    stems = fields.get('stem')    tags = fields.get('tag')    if stems and tags:        tags = listIntersection(tags, possibleStemSetTags(stems))        if not tags:            return None        fields['tag'] = tags    #if tokens and stems:    #   from stemmer import stemWord    #   possibleStems = []    #   for token in tokens:    #       possibleStems.append(stemWord(token))    #   stems = listIntersection(stems, possibleStems)    #   tokens = filter(lambda token, stems=stems, stemWord=stemWord: stemWord(token) in stems, tokens)    #   if not tokens: return None    #   fields['tokens'] = tokens    #   fields['stems'] = stems    return fields## Abbreviations#TAG_ABBREVIATIONS = {}  # fieldName -> array of (name, tagset), sorted by decreasing length of tagsetdef defineAbbreviation(name, tags, fieldName='tag'):    global TAG_ABBREVIATIONS    abbreviations = TAG_ABBREVIATIONS.get(fieldName, [])    abbreviations = filter(lambda (name, tags), this=name:name != this, abbreviations)    abbreviations.append((name, tags))    abbreviations.sort(lambda a,b:-cmp(len(a[1]), len(b[1])))    TAG_ABBREVIATIONS[fieldName] = abbreviationsdef collapseAbbreviations(tags, fieldName='tag'):    for (name, tagset) in TAG_ABBREVIATIONS.get(fieldName, []):        if listIncludes(tags, tagset):            tags = [name] + listDifference(list(tags), tagset)    return tagsdef expandAbbreviations(tags, fieldName='tag'):    # This isn't currently used --- tag abbreviations are only used for display    index  = 0    while index < len(tags):        tag = tags[index]        increment = 1        for (name, tagset) in TAG_ABBREVIATIONS.get(fieldName, []):            if tag == name:                tags[index:index + 1] = tagset                increment = 0                break        index = index + increment    return tags## Utility Functions#def listDifference(a, b):    c = []    for e in a:        if e not in b:            c.append(e)    return cdef listIntersection(a, b):    return filter(lambda e, b=b:e in b, a)def listIncludes(a, b):    for item in b:        if item not in a:            return 0    return 1def listUnion(a, b):    return list(a) + list(listDifference(b, a))