(S'822675c38199b44f85699c1653abb0fc'
p1
(ihappydoclib.parseinfo.moduleinfo
ModuleInfo
p2
(dp3
S'_namespaces'
p4
((dp5
S'FSA'
p6
(ihappydoclib.parseinfo.classinfo
ClassInfo
p7
(dp8
g4
((dp9
(dp10
S'nextStates'
p11
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp12
g4
((dp13
(dp14
tsS'_exception_info'
p15
(dsS'_parameter_names'
p16
(S'self'
p17
S'state'
p18
S'input'
p19
tsS'_parameter_info'
p20
(dp21
g19
(NNNtsg17
(NNNtsg18
(NNNtssS'_filename'
p22
S'fsa.py'
p23
sS'_docstring'
p24
S''
sS'_name'
p25
g11
sS'_parent'
p26
g7
sS'_function_info'
p27
g14
sS'_configuration_values'
p28
(dsS'_class_info'
p29
g13
sS'_comment_info'
p30
(dp31
(S'FSA'
p32
S'labelMatches'
tS' \n Accepting\n \n'
p33
s(g32
S'sorted'
tS' \n Reductions\n \n'
p34
s(g32
S'create'
tS' \n Copying\n \n'
p35
s(g32
S'complement'
tS' \n FSA operations\n \n'
p36
s(g32
S'hasArcMetadata'
tS' \n Arc Metadata Accessors\n \n'
p37
s(g32
S'__repr__'
tS' \n Presentation Methods\n \n'
p38
s(g32
S'makeStateTable'
tS' \n Initialization\n \n'
p39
s(g32
S'isEmpty'
tS' \n Predicates\n \n'
p40
s(g32
S'epsilonClosure'
tS' \n Accessors\n \n'
p41
ssS'_comments'
p42
S''
sbsS'makeStateTable'
p43
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp44
g4
((dp45
(dp46
tsg15
(dsg16
(S'self'
p47
S'default'
p48
tsg20
(dp49
g48
(I1
S'None'
Ntsg47
(NNNtssg22
g23
sg24
S''
sg25
g43
sg26
g7
sg27
g46
sg28
(dsg29
g45
sg30
g31
sg42
g39
sbsS'tuple'
p50
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp51
g4
((dp52
(dp53
tsg15
(dsg16
(S'self'
p54
tsg20
(dp55
g54
(NNNtssg22
g23
sg24
S''
sg25
g50
sg26
g7
sg27
g53
sg28
(dsg29
g52
sg30
g31
sg42
S''
sbsS'collectStates'
p56
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp57
g4
((dp58
(dp59
tsg15
(dsg16
(S'self'
p60
S'transitions'
p61
S'initialState'
p62
S'finalStates'
p63
tsg20
(dp64
g60
(NNNtsg61
(NNNtsg63
(NNNtsg62
(NNNtssg22
g23
sg24
S''
sg25
g56
sg26
g7
sg27
g59
sg28
(dsg29
g58
sg30
g31
sg42
S''
sbsS'complement'
p65
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp66
g4
((dp67
(dp68
tsg15
(dsg16
(S'self'
p69
tsg20
(dp70
g69
(NNNtssg22
g23
sg24
S''
sg25
g65
sg26
g7
sg27
g68
sg28
(dsg29
g67
sg30
g31
sg42
g36
sbsS'labels'
p71
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp72
g4
((dp73
(dp74
tsg15
(dsg16
(S'self'
p75
tsg20
(dp76
g75
(NNNtssg22
g23
sg24
S'Returns a list of transition labels.'
sg25
g71
sg26
g7
sg27
g74
sg28
(dsg29
g73
sg30
g31
sg42
S''
sbsS'determinized'
p77
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp78
g4
((dp79
(dp80
tsg15
(dsg16
(S'self'
p81
tsg20
(dp82
g81
(NNNtssg22
g23
sg24
S'Returns a deterministic FSA that accepts the same language.'
sg25
g77
sg26
g7
sg27
g80
sg28
(dsg29
g79
sg30
g31
sg42
S''
sbsS'minimized'
p83
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp84
g4
((dp85
(dp86
tsg15
(dsg16
(S'self'
p87
tsg20
(dp88
g87
(NNNtssg22
g23
sg24
S'Returns a minimal FSA that accepts the same language.'
sg25
g83
sg26
g7
sg27
g86
sg28
(dsg29
g85
sg30
g31
sg42
S''
sbsS'initializeTransitionTables'
p89
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp90
g4
((dp91
(dp92
tsg15
(dsg16
(S'self'
p93
tsg20
(dp94
g93
(NNNtssg22
g23
sg24
S''
sg25
g89
sg26
g7
sg27
g92
sg28
(dsg29
g91
sg30
g31
sg42
S''
sbsS'coerce'
p95
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp96
g4
((dp97
(dp98
tsg15
(dsg16
(S'self'
p99
S'klass'
p100
tsg20
(dp101
g99
(NNNtsg100
(NNNtssg22
g23
sg24
S''
sg25
g95
sg26
g7
sg27
g98
sg28
(dsg29
g97
sg30
g31
sg42
S''
sbsS'hasArcMetadata'
p102
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp103
g4
((dp104
(dp105
tsg15
(dsg16
(S'self'
p106
tsg20
(dp107
g106
(NNNtssg22
g23
sg24
S''
sg25
g102
sg26
g7
sg27
g105
sg28
(dsg29
g104
sg30
g31
sg42
g37
sbsS'__str__'
p108
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp109
g4
((dp110
(dp111
tsg15
(dsg16
(S'self'
p112
tsg20
(dp113
g112
(NNNtssg22
g23
sg24
S''
sg25
g108
sg26
g7
sg27
g111
sg28
(dsg29
g110
sg30
g31
sg42
S''
sbsS'stateLabelString'
p114
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp115
g4
((dp116
(dp117
tsg15
(dsg16
(S'self'
p118
S'state'
p119
tsg20
(dp120
g118
(NNNtsg119
(NNNtssg22
g23
sg24
S"A template method for specifying a state's label, for use in dot\n        diagrams. If this returns None, the default (the string representation\n        of the state) is used."
sg25
g114
sg26
g7
sg27
g117
sg28
(dsg29
g116
sg30
g31
sg42
S''
sbsS'labelMatches'
p121
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp122
g4
((dp123
(dp124
tsg15
(dsg16
(S'self'
p125
S'label'
p126
S'input'
p127
tsg20
(dp128
g127
(NNNtsg125
(NNNtsg126
(NNNtssg22
g23
sg24
S''
sg25
g121
sg26
g7
sg27
g124
sg28
(dsg29
g123
sg30
g31
sg42
g33
sbsS'computeEpsilonClosure'
p129
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp130
g4
((dp131
(dp132
tsg15
(dsg16
(S'self'
p133
S'state'
p134
tsg20
(dp135
g133
(NNNtsg134
(NNNtssg22
g23
sg24
S''
sg25
g129
sg26
g7
sg27
g132
sg28
(dsg29
g131
sg30
g31
sg42
S''
sbsS'sorted'
p136
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp137
g4
((dp138
(dp139
tsg15
(dsg16
(S'self'
p140
S'initial'
p141
tsg20
(dp142
g140
(NNNtsg141
(I1
S'0'
Ntssg22
g23
sg24
S''
sg25
g136
sg26
g7
sg27
g139
sg28
(dsg29
g138
sg30
g31
sg42
g34
sbsS'copy'
p143
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp144
g4
((dp145
(dp146
tsg15
(dsg16
(S'self'
p147
S'*args'
p148
tsg20
(dp149
g148
(NNNtsg147
(NNNtssg22
g23
sg24
S''
sg25
g143
sg26
g7
sg27
g146
sg28
(dsg29
g145
sg30
g31
sg42
S''
sbsS'addArcMetadataFor'
p150
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp151
g4
((dp152
(dp153
tsg15
(dsg16
(S'self'
p154
S'transition'
p155
S'data'
p156
tsg20
(dp157
g154
(NNNtsg155
(NNNtsg156
(NNNtssg22
g23
sg24
S''
sg25
g150
sg26
g7
sg27
g153
sg28
(dsg29
g152
sg30
g31
sg42
S''
sbsS'__init__'
p158
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp159
g4
((dp160
(dp161
tsg15
(dsg16
(S'self'
p162
S'states'
p163
S'alphabet'
p164
S'transitions'
p165
S'initialState'
p166
S'finalStates'
p167
S'arcMetadata'
p168
tsg20
(dp169
g163
(NNNtsg167
(NNNtsg164
(NNNtsg162
(NNNtsg165
(NNNtsg168
(I1
S'[]'
Ntsg166
(NNNtssg22
g23
sg24
S''
sg25
g158
sg26
g7
sg27
g161
sg28
(dsg29
g160
sg30
g31
sg42
S''
sbsS'getArcMetadata'
p170
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp171
g4
((dp172
(dp173
tsg15
(dsg16
(S'self'
p174
tsg20
(dp175
g174
(NNNtssg22
g23
sg24
S''
sg25
g170
sg26
g7
sg27
g173
sg28
(dsg29
g172
sg30
g31
sg42
S''
sbsS'setArcMetadataFor'
p176
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp177
g4
((dp178
(dp179
tsg15
(dsg16
(S'self'
p180
S'transition'
p181
S'data'
p182
tsg20
(dp183
g180
(NNNtsg181
(NNNtsg182
(NNNtssg22
g23
sg24
S''
sg25
g176
sg26
g7
sg27
g179
sg28
(dsg29
g178
sg30
g31
sg42
S''
sbsS'withoutEpsilons'
p184
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp185
g4
((dp186
(dp187
tsg15
(dsg16
(S'self'
p188
tsg20
(dp189
g188
(NNNtssg22
g23
sg24
S''
sg25
g184
sg26
g7
sg27
g187
sg28
(dsg29
g186
sg30
g31
sg42
S''
sbsS'addArcMetadata'
p190
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp191
g4
((dp192
(dp193
tsg15
(dsg16
(S'self'
p194
S'list'
p195
tsg20
(dp196
g194
(NNNtsg195
(NNNtssg22
g23
sg24
S''
sg25
g190
sg26
g7
sg27
g193
sg28
(dsg29
g192
sg30
g31
sg42
S''
sbsS'epsilonClosure'
p197
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp198
g4
((dp199
(dp200
tsg15
(dsg16
(S'self'
p201
S'state'
p202
tsg20
(dp203
g201
(NNNtsg202
(NNNtssg22
g23
sg24
S''
sg25
g197
sg26
g7
sg27
g200
sg28
(dsg29
g199
sg30
g31
sg42
g41
sbsS'additionalTransitionInfoString'
p204
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp205
g4
((dp206
(dp207
tsg15
(dsg16
(S'self'
p208
S'transition'
p209
tsg20
(dp210
g208
(NNNtsg209
(NNNtssg22
g23
sg24
S''
sg25
g204
sg26
g7
sg27
g207
sg28
(dsg29
g206
sg30
g31
sg42
S''
sbsS'create'
p211
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp212
g4
((dp213
(dp214
tsg15
(dsg16
(S'self'
p215
S'*args'
p216
tsg20
(dp217
g216
(NNNtsg215
(NNNtssg22
g23
sg24
S''
sg25
g211
sg26
g7
sg27
g214
sg28
(dsg29
g213
sg30
g31
sg42
g35
sbsS'isEmpty'
p218
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp219
g4
((dp220
(dp221
tsg15
(dsg16
(S'self'
p222
tsg20
(dp223
g222
(NNNtssg22
g23
sg24
S''
sg25
g218
sg26
g7
sg27
g221
sg28
(dsg29
g220
sg30
g31
sg42
g40
sbsS'accepts'
p224
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp225
g4
((dp226
(dp227
tsg15
(dsg16
(S'self'
p228
S'sequence'
p229
tsg20
(dp230
g228
(NNNtsg229
(NNNtssg22
g23
sg24
S''
sg25
g224
sg26
g7
sg27
g227
sg28
(dsg29
g226
sg30
g31
sg42
S''
sbsS'getArcMetadataFor'
p231
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp232
g4
((dp233
(dp234
tsg15
(dsg16
(S'self'
p235
S'transition'
p236
S'default'
p237
tsg20
(dp238
g237
(I1
S'None'
Ntsg235
(NNNtsg236
(NNNtssg22
g23
sg24
S''
sg25
g231
sg26
g7
sg27
g234
sg28
(dsg29
g233
sg30
g31
sg42
S''
sbsS'nextState'
p239
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp240
g4
((dp241
(dp242
tsg15
(dsg16
(S'self'
p243
S'state'
p244
S'input'
p245
tsg20
(dp246
g245
(NNNtsg243
(NNNtsg244
(NNNtssg22
g23
sg24
S''
sg25
g239
sg26
g7
sg27
g242
sg28
(dsg29
g241
sg30
g31
sg42
S''
sbsS'trimmed'
p247
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp248
g4
((dp249
(dp250
tsg15
(dsg16
(S'self'
p251
tsg20
(dp252
g251
(NNNtssg22
g23
sg24
S"Returns an equivalent FSA that doesn't include unreachable states,\n        or states that only lead to dead states."
sg25
g247
sg26
g7
sg27
g250
sg28
(dsg29
g249
sg30
g31
sg42
S''
sbsS'isFSA'
p253
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp254
g4
((dp255
(dp256
tsg15
(dsg16
(S'self'
p257
tsg20
(dp258
g257
(NNNtssg22
g23
sg24
S''
sg25
g253
sg26
g7
sg27
g256
sg28
(dsg29
g255
sg30
g31
sg42
S''
sbsS'creationArgs'
p259
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp260
g4
((dp261
(dp262
tsg15
(dsg16
(S'self'
p263
tsg20
(dp264
g263
(NNNtssg22
g23
sg24
S''
sg25
g259
sg26
g7
sg27
g262
sg28
(dsg29
g261
sg30
g31
sg42
S''
sbsS'__repr__'
p265
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp266
g4
((dp267
(dp268
tsg15
(dsg16
(S'self'
p269
tsg20
(dp270
g269
(NNNtssg22
g23
sg24
S''
sg25
g265
sg26
g7
sg27
g268
sg28
(dsg29
g267
sg30
g31
sg42
g38
sbsS'setArcMetadata'
p271
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp272
g4
((dp273
(dp274
tsg15
(dsg16
(S'self'
p275
S'list'
p276
tsg20
(dp277
g275
(NNNtsg276
(NNNtssg22
g23
sg24
S''
sg25
g271
sg26
g7
sg27
g274
sg28
(dsg29
g273
sg30
g31
sg42
S''
sbsS'nextAvailableState'
p278
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp279
g4
((dp280
(dp281
tsg15
(dsg16
(S'self'
p282
tsg20
(dp283
g282
(NNNtssg22
g23
sg24
S''
sg25
g278
sg26
g7
sg27
g281
sg28
(dsg29
g280
sg30
g31
sg42
S''
sbsS'computeEpsilonClosures'
p284
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp285
g4
((dp286
(dp287
tsg15
(dsg16
(S'self'
p288
tsg20
(dp289
g288
(NNNtssg22
g23
sg24
S''
sg25
g284
sg26
g7
sg27
g287
sg28
(dsg29
g286
sg30
g31
sg42
S''
sbsS'view'
p290
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp291
g4
((dp292
(dp293
tsg15
(dsg16
(S'self'
p294
tsg20
(dp295
g294
(NNNtssg22
g23
sg24
S''
sg25
g290
sg26
g7
sg27
g293
sg28
(dsg29
g292
sg30
g31
sg42
S''
sbsS'nextStateSet'
p296
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp297
g4
((dp298
(dp299
tsg15
(dsg16
(S'self'
p300
S'states'
p301
S'input'
p302
tsg20
(dp303
g301
(NNNtsg302
(NNNtsg300
(NNNtssg22
g23
sg24
S''
sg25
g296
sg26
g7
sg27
g299
sg28
(dsg29
g298
sg30
g31
sg42
S''
sbsS'toDotString'
p304
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp305
g4
((dp306
(dp307
tsg15
(dsg16
(S'self'
p308
tsg20
(dp309
g308
(NNNtssg22
g23
sg24
S'Returns a string that can be printed by the DOT tool at\n        http://www.research.att.com/sw/tools/graphviz/ .'
sg25
g304
sg26
g7
sg27
g307
sg28
(dsg29
g306
sg30
g31
sg42
S''
sbsS'transitionsFrom'
p310
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp311
g4
((dp312
(dp313
tsg15
(dsg16
(S'self'
p314
S'state'
p315
tsg20
(dp316
g314
(NNNtsg315
(NNNtssg22
g23
sg24
S''
sg25
g310
sg26
g7
sg27
g313
sg28
(dsg29
g312
sg30
g31
sg42
S''
sbstsg22
g23
sg24
S''
sS'_class_member_info'
p317
(lsg25
g6
sg26
g2
sg27
g10
sg42
S''
sg28
(dsg29
g9
sg30
g31
sS'_base_class_info'
p318
(lsbs(dp319
S'trim'
p320
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp321
g4
((dp322
(dp323
tsg15
(dsg16
(S'fsa'
p324
tsg20
(dp325
g324
(NNNtssg22
g23
sg24
S''
sg25
g320
sg26
g2
sg27
g323
sg28
(dsg29
g322
sg30
g31
sg42
S''
sbsS'completion'
p326
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp327
g4
((dp328
(dp329
tsg15
(dsg16
(S'fsa'
p330
tsg20
(dp331
g330
(NNNtssg22
g23
sg24
S'Returns an FSA that accepts the same language as the argument, but that\n    lands in a defined state for every input.'
sg25
g326
sg26
g2
sg27
g329
sg28
(dsg29
g328
sg30
g31
sg42
S''
sbsS'singleton'
p332
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp333
g4
((dp334
(dp335
tsg15
(dsg16
(S'symbol'
p336
S'alphabet'
p337
S'arcMetadata'
p338
tsg20
(dp339
g337
(I1
S'None'
Ntsg336
(NNNtsg338
(I1
S'None'
Ntssg22
g23
sg24
S''
sg25
g332
sg26
g2
sg27
g335
sg28
(dsg29
g334
sg30
g31
sg42
S''
sbsS'option'
p340
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp341
g4
((dp342
(dp343
tsg15
(dsg16
(S'fsa'
p344
tsg20
(dp345
g344
(NNNtssg22
g23
sg24
S''
sg25
g340
sg26
g2
sg27
g343
sg28
(dsg29
g342
sg30
g31
sg42
S''
sbsS'sequence'
p346
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp347
g4
((dp348
(dp349
tsg15
(dsg16
(S'sequence'
p350
S'alphabet'
p351
tsg20
(dp352
g351
(I1
S'None'
Ntsg350
(NNNtssg22
g23
sg24
S''
sg25
g346
sg26
g2
sg27
g349
sg28
(dsg29
g348
sg30
g31
sg42
S''
sbsS'equivalent'
p353
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp354
g4
((dp355
(dp356
tsg15
(dsg16
(S'a'
S'b'
tsg20
(dp357
S'a'
(NNNtsS'b'
(NNNtssg22
g23
sg24
S'Return true ifff a and b accept the same language.'
sg25
g353
sg26
g2
sg27
g356
sg28
(dsg29
g355
sg30
g31
sg42
S''
sbsS'unionLabelSets'
p358
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp359
g4
((dp360
(dp361
tsg15
(dsg16
(S'alist'
p362
S'blist'
p363
S'alphabet'
p364
tsg20
(dp365
g364
(I1
S'None'
Ntsg363
(NNNtsg362
(NNNtssg22
g23
sg24
S''
sg25
g358
sg26
g2
sg27
g361
sg28
(dsg29
g360
sg30
g31
sg42
S''
sbsS'symbolComplement'
p366
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp367
g4
((dp368
(dp369
tsg15
(dsg16
(S'symbol'
p370
tsg20
(dp371
g370
(NNNtssg22
g23
sg24
S''
sg25
g366
sg26
g2
sg27
g369
sg28
(dsg29
g368
sg30
g31
sg42
S''
sbsS'concatenation'
p372
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp373
g4
((dp374
(dp375
tsg15
(dsg16
(S'a'
S'*args'
p376
tsg20
(dp377
S'a'
(NNNtsg376
(NNNtssg22
g23
sg24
S'Returns an FSA that accepts the language consisting of the concatenation\n    of strings recognized by the arguments.'
sg25
g372
sg26
g2
sg27
g375
sg28
(dsg29
g374
sg30
g31
sg42
S''
sbsS'sort'
p378
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp379
g4
((dp380
(dp381
tsg15
(dsg16
(S'fsa'
p382
tsg20
(dp383
g382
(NNNtssg22
g23
sg24
S''
sg25
g378
sg26
g2
sg27
g381
sg28
(dsg29
g380
sg30
g31
sg42
S''
sbsS'labelIntersection'
p384
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp385
g4
((dp386
(dp387
tsg15
(dsg16
(S'l1'
p388
S'l2'
p389
tsg20
(dp390
g389
(NNNtsg388
(NNNtssg22
g23
sg24
S''
sg25
g384
sg26
g2
sg27
g387
sg28
(dsg29
g386
sg30
g31
sg42
S''
sbsS'intersectLabelSets'
p391
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp392
g4
((dp393
(dp394
tsg15
(dsg16
(S'alist'
p395
S'blist'
p396
tsg20
(dp397
g396
(NNNtsg395
(NNNtssg22
g23
sg24
S''
sg25
g391
sg26
g2
sg27
g394
sg28
(dsg29
g393
sg30
g31
sg42
S''
sbsS'labelString'
p398
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp399
g4
((dp400
(dp401
tsg15
(dsg16
(S'label'
p402
tsg20
(dp403
g402
(NNNtssg22
g23
sg24
S''
sg25
g398
sg26
g2
sg27
g401
sg28
(dsg29
g400
sg30
g31
sg42
S''
sbsS'compileItem'
p404
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp405
g4
((dp406
(dp407
tsg15
(dp408
S"'unimplemented'"
Nssg16
(S'str'
p409
S'index'
p410
S'options'
p411
tsg20
(dp412
g410
(NNNtsg411
(NNNtsg409
(NNNtssg22
g23
sg24
S''
sg25
g404
sg26
g2
sg27
g407
sg28
(dsg29
g406
sg30
g31
sg42
S''
sbsS'labelComplement'
p413
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp414
g4
((dp415
(dp416
tsg15
(dsg16
(S'label'
p417
S'alphabet'
p418
tsg20
(dp419
g418
(NNNtsg417
(NNNtssg22
g23
sg24
S''
sg25
g413
sg26
g2
sg27
g416
sg28
(dsg29
g415
sg30
g31
sg42
S''
sbsS'removeDuplicates'
p420
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp421
g4
((dp422
(dp423
tsg15
(dsg16
(S'sequence'
p424
tsg20
(dp425
g424
(NNNtssg22
g23
sg24
S''
sg25
g420
sg26
g2
sg27
g423
sg28
(dsg29
g422
sg30
g31
sg42
S''
sbsS'difference'
p426
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp427
g4
((dp428
(dp429
tsg15
(dsg16
(S'a'
S'b'
tsg20
(dp430
S'a'
(NNNtsS'b'
(NNNtssg22
g23
sg24
S'Returns an FSA that accepts those strings accepted by the first\n    argument, but not the second.'
sg25
g426
sg26
g2
sg27
g429
sg28
(dsg29
g428
sg30
g31
sg42
S''
sbsS'compileREExpr'
p431
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp432
g4
((dp433
(dp434
tsg15
(dsg16
(S'str'
p435
S'index'
p436
S'options'
p437
tsg20
(dp438
g436
(NNNtsg437
(NNNtsg435
(NNNtssg22
g23
sg24
S''
sg25
g431
sg26
g2
sg27
g434
sg28
(dsg29
g433
sg30
g31
sg42
S''
sbsS'complementLabelSet'
p439
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp440
g4
((dp441
(dp442
tsg15
(dsg16
(S'labels'
p443
S'alphabet'
p444
tsg20
(dp445
g444
(I1
S'None'
Ntsg443
(NNNtssg22
g23
sg24
S''
sg25
g439
sg26
g2
sg27
g442
sg28
(dsg29
g441
sg30
g31
sg42
S''
sbsS'compileRE'
p446
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp447
g4
((dp448
(dp449
tsg15
(dp450
S"'extra ' + ` ')' `"
Nssg16
(S's'
S'**options'
p451
tsg20
(dp452
S's'
(NNNtsg451
(NNNtssg22
g23
sg24
S''
sg25
g446
sg26
g2
sg27
g449
sg28
(dsg29
g448
sg30
g31
sg42
S''
sbsS'closure'
p453
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp454
g4
((dp455
(dp456
tsg15
(dsg16
(S'arg'
p457
tsg20
(dp458
g457
(NNNtssg22
g23
sg24
S''
sg25
g453
sg26
g2
sg27
g456
sg28
(dsg29
g455
sg30
g31
sg42
S''
sbsS'labelComplements'
p459
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp460
g4
((dp461
(dp462
tsg15
(dsg16
(S'label'
p463
S'alphabet'
p464
tsg20
(dp465
g464
(NNNtsg463
(NNNtssg22
g23
sg24
S''
sg25
g459
sg26
g2
sg27
g462
sg28
(dsg29
g461
sg30
g31
sg42
S''
sbsS'intersection'
p466
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp467
g4
((dp468
(dp469
tsg15
(dsg16
(S'a'
S'b'
tsg20
(dp470
S'a'
(NNNtsS'b'
(NNNtssg22
g23
sg24
S'Returns the intersection of two FSAs'
sg25
g466
sg26
g2
sg27
g469
sg28
(dsg29
g468
sg30
g31
sg42
S''
sbsS'reverse'
p471
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp472
g4
((dp473
(dp474
tsg15
(dsg16
(S'fsa'
p475
tsg20
(dp476
g475
(NNNtssg22
g23
sg24
S''
sg25
g471
sg26
g2
sg27
g474
sg28
(dsg29
g473
sg30
g31
sg42
S''
sbsS'determinize'
p477
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp478
g4
((dp479
(dp480
tsg15
(dsg16
(S'fsa'
p481
tsg20
(dp482
g481
(NNNtssg22
g23
sg24
S''
sg25
g477
sg26
g2
sg27
g480
sg28
(dsg29
g479
sg30
g31
sg42
S''
sbsS'union'
p483
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp484
g4
((dp485
(dp486
tsg15
(dsg16
(S'*args'
p487
tsg20
(dp488
g487
(NNNtssg22
g23
sg24
S''
sg25
g483
sg26
g2
sg27
g486
sg28
(dsg29
g485
sg30
g31
sg42
S''
sbsS'symbolIntersection'
p489
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp490
g4
((dp491
(dp492
tsg15
(dsg16
(S's1'
p493
S's2'
p494
tsg20
(dp495
g494
(NNNtsg493
(NNNtssg22
g23
sg24
S''
sg25
g489
sg26
g2
sg27
g492
sg28
(dsg29
g491
sg30
g31
sg42
S''
sbsS'compileSequence'
p496
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp497
g4
((dp498
(dp499
tsg15
(dsg16
(S'str'
p500
S'index'
p501
S'options'
p502
tsg20
(dp503
g501
(NNNtsg502
(NNNtsg500
(NNNtssg22
g23
sg24
S''
sg25
g496
sg26
g2
sg27
g499
sg28
(dsg29
g498
sg30
g31
sg42
S''
sbsS'iteration'
p504
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp505
g4
((dp506
(dp507
tsg15
(dsg16
(S'fsa'
p508
S'min'
p509
S'max'
p510
tsg20
(dp511
g508
(NNNtsg510
(I1
S'None'
Ntsg509
(I1
S'1'
Ntssg22
g23
sg24
S"\n    >>> equivalent(iteration(singleton('a', 0, 2)), compileRE('|a|aa'))\n    >>> equivalent(iteration(singleton('a', 1, 2)), compileRE('a|aa'))\n    >>> equivalent(iteration(singleton('a', 1)), compileRE('aa*'))\n    "
sg25
g504
sg26
g2
sg27
g507
sg28
(dsg29
g506
sg30
g31
sg42
S''
sbsS'constructLabelMap'
p512
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp513
g4
((dp514
(dp515
tsg15
(dsg16
(S'labels'
p516
S'alphabet'
p517
S'includeComplements'
p518
tsg20
(dp519
g517
(NNNtsg516
(NNNtsg518
(I1
S'0'
Ntssg22
g23
sg24
S'Return a list of (newLabel, positives), where newLabel is an\n    intersection of elements from labels and their complemens, and positives is\n    a list of labels that have non-empty intersections with newLabel.'
sg25
g512
sg26
g2
sg27
g515
sg28
(dsg29
g514
sg30
g31
sg42
S''
sbsS'toFSA'
p520
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp521
g4
((dp522
(dp523
tsg15
(dsg16
(S'arg'
p524
tsg20
(dp525
g524
(NNNtssg22
g23
sg24
S''
sg25
g520
sg26
g2
sg27
g523
sg28
(dsg29
g522
sg30
g31
sg42
S''
sbsS'compileConjunction'
p526
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp527
g4
((dp528
(dp529
tsg15
(dsg16
(S'str'
p530
S'index'
p531
S'options'
p532
tsg20
(dp533
g531
(NNNtsg532
(NNNtsg530
(NNNtssg22
g23
sg24
S''
sg25
g526
sg26
g2
sg27
g529
sg28
(dsg29
g528
sg30
g31
sg42
S''
sbsS'minimize'
p534
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp535
g4
((dp536
(dp537
tsg15
(dsg16
(S'fsa'
p538
tsg20
(dp539
g538
(NNNtssg22
g23
sg24
S''
sg25
g534
sg26
g2
sg27
g537
sg28
(dsg29
g536
sg30
g31
sg42
S''
sbsS'consolidateTransitions'
p540
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp541
g4
((dp542
(dp543
tsg15
(dsg16
(S'transitions'
p544
tsg20
(dp545
g544
(NNNtssg22
g23
sg24
S''
sg25
g540
sg26
g2
sg27
g543
sg28
(dsg29
g542
sg30
g31
sg42
S''
sbsS'containment'
p546
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp547
g4
((dp548
(dp549
tsg15
(dsg16
(S'arg'
p550
S'occurrences'
p551
tsg20
(dp552
g551
(I1
S'1'
Ntsg550
(NNNtssg22
g23
sg24
S'Returns an FSA that matches sequences containing at least _count_\n    occurrences\n    of _symbol_.'
sg25
g546
sg26
g2
sg27
g549
sg28
(dsg29
g548
sg30
g31
sg42
S''
sbsS'labelMatches'
p553
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp554
g4
((dp555
(dp556
tsg15
(dsg16
(S'label'
p557
S'input'
p558
tsg20
(dp559
g558
(NNNtsg557
(NNNtssg22
g23
sg24
S''
sg25
g553
sg26
g2
sg27
g556
sg28
(dsg29
g555
sg30
g31
sg42
S''
sbsS'_labelIntersection'
p560
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp561
g4
((dp562
(dp563
tsg15
(dsg16
(S'l1'
p564
S'l2'
p565
tsg20
(dp566
g565
(NNNtsg564
(NNNtssg22
g23
sg24
S''
sg25
g560
sg26
g2
sg27
g563
sg28
(dsg29
g562
sg30
g31
sg42
S''
sbsS'complement'
p567
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp568
g4
((dp569
(dp570
tsg15
(dsg16
(S'arg'
p571
tsg20
(dp572
g571
(NNNtssg22
g23
sg24
S'Returns an FSA that accepts exactly those strings that the argument does\n    not.'
sg25
g567
sg26
g2
sg27
g570
sg28
(dsg29
g569
sg30
g31
sg42
S''
sbsS'view'
p573
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
(dp574
g4
((dp575
(dp576
tsg15
(dsg16
(S'str'
p577
tsg20
(dp578
g577
(NNNtssg22
g23
sg24
S''
sg25
g573
sg26
g2
sg27
g576
sg28
(dsg29
g575
sg30
g31
sg42
S''
sbstsS'_import_info'
p579
(ihappydoclib.parseinfo.imports
ImportInfo
(dp580
S'_named_imports'
p581
(dp582
S'types'
(lp583
S'InstanceType'
aS'ListType'
aS'IntType'
aS'LongType'
assS'_straight_imports'
p584
(lsbsg22
g23
sg24
S'""" methods to manipulate finite-state automata\n\nThis module defines an FSA class, for representing and operating on\nfinite-state automata (FSAs). FSAs can be used to represent regular\nexpressions and to test sequences for membership in the languages\ndescribed by regular expressions.\n\nFSAs can be deterministic or nondeterministic, and they can contain\nepsilon transitions. Methods to determinize an automaton (also\neliminating its epsilon transitions), and to minimize an automaton,\nare provided.\n\nThe transition labels for an FSA can be symbols from an alphabet, as\nin the standard formal definition of an FSA, but they can also be\ninstances which represent predicates. If these instances implement\ninstance.matches(), then the FSA nextState() function and accepts()\npredicate can be used. If they implement instance.complement() and\ninstance.intersection(), the FSA can be be determinized and minimized,\nto find a minimal deterministic FSA that accepts an equivalent\nlanguage.\n\n\nQuick Start\n----------\nInstances of FSA can be created out of labels (for instance, strings)\nby the singleton() function, and combined to create more complex FSAs\nthrough the complement(), closure(), concatenation(), union(), and\nother constructors. For example, concatenation(singleton(\'a\'),\nunion(singleton(\'b\'), closure(singleton(\'c\')))) creates an FSA that\naccepts the strings \'a\', \'ab\', \'ac\', \'acc\', \'accc\', and so on.\n\nInstances of FSA can also be created with the compileRE() function,\nwhich compiles a simple regular expression (using only \'*\', \'?\', \'+\',\n\'|\', \'(\', and \')\' as metacharacters) into an FSA. For example,\ncompileRE(\'a(b|c*)\') returns an FSA equivalent to the example in the\nprevious paragraph.\n\nFSAs can be determinized, to create equivalent FSAs (FSAs accepting\nthe same language) with unique successor states for each input, and\nminimized, to create an equivalent deterministic FSA with the smallest\nnumber of states. FSAs can also be complemented, intersected, unioned,\nand so forth as described under \'FSA Functions\' below.\n\n\nFSA Methods\n-----------\nThe class FSA defines the following methods.\n\nAcceptance\n``````````\nfsa.nextStates(state, input)\n  returns a list of states\nfsa.nextState(state, input)\n  returns None or a single state if\n  |nextStates| <= 1, otherwise it raises an exception\nfsa.nextStateSet(states, input)\n  returns a list of states\nfsa.accepts(sequence)\n  returns true or false\n\nAccessors and predicates\n````````````````````````\nisEmpty()\n  returns true iff the language accepted by the FSA is the empty language\nlabels()\n  returns a list of labels that are used in any transition\nnextAvailableState()\n  returns an integer n such that no states in the FSA\n  are numeric values >= n\n\nReductions\n``````````\nsorted(initial=0)\n  returns an equivalent FSA whose states are numbered\n  upwards from 0\ndeterminized()\n  returns an equivalent deterministic FSA\nminimized()\n  returns an equivalent minimal FSA\ntrimmed()\n  returns an equivalent FSA that contains no unreachable or dead\n  states\n\nPresentation\n````````````\ntoDotString()\n  returns a string suitable as *.dot file for the \'dot\'\n  program from AT&T GraphViz\nview()\n  views the FSA with a gs viewer, if gs and dot are installed\n\n\nFSA Functions\n------------\nConstruction from FSAs\n``````````````````````\ncomplement(a)\n  returns an fsa that accepts exactly those sequences that its\n  argument does not\nclosure(a)\n  returns an fsa that accepts sequences composed of zero or more\n  concatenations of sequences accepted by the argument\nconcatenation(a, b)\n  returns an fsa that accepts sequences composed of a\n  sequence accepted by a, followed by a sequence accepted by b\ncontainment(a, occurrences=1)\n  returns an fsa that accepts sequences that\n  contain at least occurrences occurrences of a subsequence recognized by the\n  argument.\ndifference(a, b)\n  returns an fsa that accepts those sequences accepted by a\n  but not b\nintersection(a, b)\n  returns an fsa that accepts sequences accepted by both a\n  and b\niteration(a, min=1, max=None)\n  returns an fsa that accepts sequences\n  consisting of from min to max (or any number, if max is None) of sequences\n  accepted by its first argument\noption(a)\n  equivalent to union(a, EMPTY_STRING_FSA)\nreverse(a)\n  returns an fsa that accepts strings whose reversal is accepted by\n  the argument\nunion(a, b)\n  returns an fsa that accepts sequences accepted by both a and b\n\nPredicates\n``````````\nequivalent(a, b)\n  returns true iff a and b accept the same language\n\nReductions (these equivalent to the similarly-named methods)\n````````````````````````````````````````````````````````````\ndeterminize(fsa)\n  returns an equivalent deterministic FSA\nminimize(fsa)\n  returns an equivalent minimal FSA\nsort(fsa, initial=0)\n  returns an equivalent FSA whose states are numbered from\n  initial\ntrim(fsa)\n  returns an equivalent FSA that contains no dead or unreachable\n  states\n\nConstruction from labels\n````````````````````````\ncompileRE(string)\n  returns an FSA that accepts the language described by\n  string, where string is a list of symbols and \'*\', \'+\', \'?\', and \'|\' operators,\n    with \'(\' and \')\' to control precedence.\nsequence(sequence)\n  returns an fsa that accepts sequences that are matched by\n  the elements of the argument. For example, sequence(\'abc\') returns an fsa that\n  accepts \'abc\' and [\'a\', \'b\', \'c\'].\nsingleton(label)\n  returns an fsa that accepts singletons whose elements are\n  matched by label. For example, singleton(\'a\') returns an fsa that accepts only\n  the string \'a\'.\n\n\nFSA Constants\n------------\nEMPTY_STRING_FSA is an FSA that accepts the language consisting only\nof the empty string.\n\nNULL_FSA is an FSA that accepts the null language.\n\nUNIVERSAL_FSA is an FSA that accepts S*, where S is any object.\n\n\nFSA instance creation\n---------------------\nFSA is initialized with a list of states, an alphabet, a list of\ntransition, an initial state, and a list of final states. If fsa is an\nFSA, fsa.tuple() returns these values in that order, i.e. (states,\nalphabet, transitions, initialState, finalStates). They\'re also\navailable as fields of fsa with those names.\n\nEach element of transition is a tuple of a start state, an end state,\nand a label: (startState, endSTate, label).\n\nIf the list of states is None, it\'s computed from initialState,\nfinalStates, and the states in transitions.\n\nIf alphabet is None, an open alphabet is used: labels are assumed to\nbe objects that implements label.matches(input), label.complement(),\nand label.intersection() as follows:\n\n    - label.matches(input) returns true iff label matches input\n    - label.complement() returnseither a label or a list of labels which,\n        together with the receiver, partition the input alphabet\n    - label.intersection(other) returns either None (if label and other don\'t\n        both match any symbol), or a label that matches the set of symbols that\n        both label and other match\n\nAs a special case, strings can be used as labels. If a strings \'a\' and\n\'b\' are used as a label and there\'s no alphabet, \'~a\' and \'~b\' are\ntheir respective complements, and \'~a&~b\' is the intersection of \'~a\'\nand \'~b\'. (The intersections of \'a\' and \'b\', \'a\' and \'~b\', and \'~a\'\nand \'b\' are, respectively, None, \'a\', and \'b\'.)\n\n\nGoals\n-----\nDesign Goals:\n\n- easy to use\n- easy to read (simple implementation, direct expression of algorithms)\n- extensible\n\nNon-Goals:\n\n- efficiency\n"""'
sg25
S'fsa'
sg26
Nsg27
g319
sg28
(dp585
S'include_comments'
p586
I1
sS'cacheFilePrefix'
p587
S'.happydoc.'
p588
sS'useCache'
p589
I1
sS'docStringFormat'
p590
S'StructuredText'
p591
ssg29
g5
sg30
g31
sg42
S''
sbt.