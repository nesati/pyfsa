
<!doctype html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module FSChartParser</title>
<style type="text/css"><!--
TT { font-family: lucidatypewriter, lucida console, courier }
--></style></head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>FSChartParser</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:///C|/documents%20and%20settings/oliver%20steele/my%20documents/projects/fsa/fschartparser.py">c:\documents and settings\oliver steele\my documents\projects\fsa\fschartparser.py</a></font></td></tr></table>
    <p><tt>#&nbsp;Module&nbsp;FSChartParser&nbsp;--&nbsp;finite-state&nbsp;chart&nbsp;parser&nbsp;and&nbsp;grammar&nbsp;compilation&nbsp;utilities"""ChartParser&nbsp;is&nbsp;a&nbsp;chart&nbsp;parser&nbsp;that&nbsp;uses&nbsp;finite-state&nbsp;automata&nbsp;torecognize&nbsp;grammar&nbsp;rules.ChartParser&nbsp;is&nbsp;initialized&nbsp;with&nbsp;a&nbsp;grammar,&nbsp;represented&nbsp;as&nbsp;a&nbsp;list&nbsp;ofrules.&nbsp;Each&nbsp;rule&nbsp;is&nbsp;either&nbsp;a&nbsp;categorizing&nbsp;automaton&nbsp;(defined&nbsp;below),or&nbsp;a&nbsp;tuple&nbsp;(lhs,&nbsp;automaton),&nbsp;where&nbsp;each&nbsp;lhs&nbsp;is&nbsp;a&nbsp;category&nbsp;and&nbsp;eachautomaton&nbsp;recognizes&nbsp;a&nbsp;language&nbsp;over&nbsp;terminals,&nbsp;and&nbsp;nonterminals.&nbsp;Inthe&nbsp;latter&nbsp;case,&nbsp;the&nbsp;tuple&nbsp;is&nbsp;compiled&nbsp;to&nbsp;a&nbsp;categorizing&nbsp;automaton.A&nbsp;categorizing&nbsp;automaton&nbsp;is&nbsp;an&nbsp;automaton&nbsp;which&nbsp;also&nbsp;maps&nbsp;each&nbsp;finalstate&nbsp;to&nbsp;a&nbsp;list&nbsp;of&nbsp;categories,&nbsp;which&nbsp;index&nbsp;the&nbsp;languages&nbsp;thatcategorize&nbsp;a&nbsp;sequence&nbsp;that&nbsp;leads&nbsp;to&nbsp;that&nbsp;final&nbsp;state.&nbsp;A&nbsp;categorizingautomaton&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;simultaneously&nbsp;apply&nbsp;a&nbsp;number&nbsp;of&nbsp;regulargrammars&nbsp;to&nbsp;a&nbsp;single&nbsp;input&nbsp;sequence,&nbsp;and&nbsp;categorize&nbsp;each&nbsp;subsequenceaccording&nbsp;to&nbsp;each&nbsp;grammar.&nbsp;Categorizing&nbsp;automata&nbsp;are&nbsp;represented&nbsp;byinstances&nbsp;of&nbsp;class&nbsp;CategorizingAutomaton,&nbsp;and&nbsp;created&nbsp;bycompileCategorizingAutomaton,&nbsp;which&nbsp;takes&nbsp;a&nbsp;list&nbsp;of&nbsp;(lhs,&nbsp;automaton)rules&nbsp;and&nbsp;constructs&nbsp;a&nbsp;single&nbsp;categorizing&nbsp;automaton&nbsp;which&nbsp;categorizesinputs&nbsp;according&nbsp;to&nbsp;all&nbsp;the&nbsp;rules&nbsp;simultaneously.The&nbsp;chart&nbsp;parser&nbsp;operates&nbsp;on&nbsp;instances&nbsp;of&nbsp;Constituent,&nbsp;which&nbsp;has&nbsp;acategory,&nbsp;a&nbsp;start&nbsp;index,&nbsp;an&nbsp;end&nbsp;index,&nbsp;and&nbsp;a&nbsp;list&nbsp;of&nbsp;children,&nbsp;whichare&nbsp;also&nbsp;constituents.Example--------&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;RULES&nbsp;=&nbsp;map(lambda&nbsp;(lhs,&nbsp;rhs):(lhs,&nbsp;FSA.compileRE(rhs,&nbsp;multichar=1)),&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('S',&nbsp;'NP&nbsp;VP'),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('NP',&nbsp;"det?&nbsp;adj*&nbsp;noun+"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('NP',&nbsp;'noun&nbsp;of&nbsp;noun'),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('VP',&nbsp;'verb&nbsp;NP')])&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;parser&nbsp;=&nbsp;ChartParser(compileRules(RULES))&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;print&nbsp;parser.parseString('noun&nbsp;verb&nbsp;noun',&nbsp;multichar=1).constituents()&nbsp;&nbsp;&nbsp;&nbsp;[S[NP[noun]&nbsp;VP[verb&nbsp;NP[noun]]]]&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;print&nbsp;parser.parseString('det&nbsp;adj&nbsp;noun&nbsp;noun&nbsp;verb&nbsp;adj&nbsp;noun',&nbsp;multichar=1).constituents()&nbsp;&nbsp;&nbsp;&nbsp;[S[NP[det&nbsp;adj&nbsp;noun&nbsp;noun]&nbsp;VP[verb&nbsp;NP[adj&nbsp;noun]]]]&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;parser&nbsp;=&nbsp;ChartParser(compileRules(RULES,&nbsp;optimize=1))&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;print&nbsp;parser.parseString('noun&nbsp;verb&nbsp;noun',&nbsp;multichar=1)&nbsp;&nbsp;&nbsp;&nbsp;[S[NP[noun]&nbsp;VP[verb&nbsp;NP[noun]]]]"""__author__&nbsp;&nbsp;=&nbsp;"Oliver&nbsp;Steele",&nbsp;'steele@osteele.com'import&nbsp;FSAfrom&nbsp;types&nbsp;import&nbsp;ListType,&nbsp;StringType,&nbsp;TupleTypeclass&nbsp;ChartParser:&nbsp;&nbsp;&nbsp;&nbsp;TRACE&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;TRACE_MATCHES&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;TRACE_CONSTITUENTS&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Initialization&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;rules):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Each&nbsp;rule&nbsp;is&nbsp;a&nbsp;sequence&nbsp;of&nbsp;f,&nbsp;fsa;&nbsp;where&nbsp;f&nbsp;is&nbsp;applied&nbsp;to&nbsp;(fsa,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state,&nbsp;children,&nbsp;start,&nbsp;end)&nbsp;to&nbsp;create&nbsp;a&nbsp;constituent&nbsp;or&nbsp;None,&nbsp;and&nbsp;fsa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;a&nbsp;finite-state&nbsp;automaton&nbsp;as&nbsp;defined&nbsp;in&nbsp;FSA."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>automata</strong>&nbsp;=&nbsp;rules&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>firstConstituentsOnly</strong>&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;initializeChart(self,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>constituentMaps</strong>&nbsp;=&nbsp;map(lambda&nbsp;n:{},&nbsp;range(n))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>edges</strong>&nbsp;=&nbsp;map(lambda&nbsp;n:[],&nbsp;range(n&nbsp;+&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#for&nbsp;automaton&nbsp;in&nbsp;self.<strong>automata</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(n):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addEdge((automaton,&nbsp;automaton.initialState,&nbsp;i,&nbsp;i,&nbsp;[]))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Parsing&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;parse(self,&nbsp;tokens):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Preterminals&nbsp;should&nbsp;be&nbsp;a&nbsp;sequence&nbsp;of&nbsp;tokens.&nbsp;Parse&nbsp;it.&nbsp;If&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there's&nbsp;a&nbsp;set&nbsp;of&nbsp;spanning&nbsp;parses&nbsp;whose&nbsp;categories&nbsp;match&nbsp;the&nbsp;categories&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;first&nbsp;grammar&nbsp;rule,&nbsp;return&nbsp;them.&nbsp;For&nbsp;more&nbsp;general&nbsp;queries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(partial&nbsp;parses),&nbsp;use&nbsp;the&nbsp;query&nbsp;methods&nbsp;on&nbsp;the&nbsp;parser."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>tokens</strong>&nbsp;=&nbsp;tokens&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initializeChart(len(tokens))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>finalIndex</strong>&nbsp;=&nbsp;len(tokens)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(len(tokens)):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;automaton&nbsp;in&nbsp;self.<strong>automata</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addEdge(automaton,&nbsp;automaton.initialState,&nbsp;i,&nbsp;i,&nbsp;[])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;parseString(self,&nbsp;sentence,&nbsp;multichar=0):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Parse&nbsp;the&nbsp;string&nbsp;argument,&nbsp;with&nbsp;one&nbsp;letter&nbsp;per&nbsp;preterminal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituent.&nbsp;If&nbsp;multichar&nbsp;is&nbsp;true,&nbsp;the&nbsp;string&nbsp;is&nbsp;split&nbsp;at&nbsp;whitespace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;intervening&nbsp;tokens&nbsp;are&nbsp;used&nbsp;as&nbsp;preterminals&nbsp;instead."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;multichar:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;string.split(sentence)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;sentence&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;parse(tokens)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Queries&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;constituents(self,&nbsp;categories=None,&nbsp;complete=0):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Return&nbsp;a&nbsp;list&nbsp;of&nbsp;all&nbsp;the&nbsp;non-preterminal&nbsp;constituents&nbsp;in&nbsp;the&nbsp;chart.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;categories&nbsp;is&nbsp;not&nbsp;false,&nbsp;include&nbsp;only&nbsp;constituents&nbsp;with&nbsp;a&nbsp;category&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;categories."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;constituentMap&nbsp;in&nbsp;self.<strong>constituentMaps</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituents&nbsp;=&nbsp;constituentMap.values()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;categories:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituents&nbsp;=&nbsp;filter(lambda&nbsp;c,cats=categories:c.category&nbsp;in&nbsp;cats,&nbsp;constituents)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituents.sort(lambda&nbsp;a,&nbsp;b:-cmp(a.length(),&nbsp;b.length()))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results.extend(constituents)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;complete:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results&nbsp;=&nbsp;filter(lambda&nbsp;c,&nbsp;final=self.<strong>finalIndex</strong>:&nbsp;c.start&nbsp;==&nbsp;0&nbsp;and&nbsp;c.end&nbsp;==&nbsp;final,&nbsp;results)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;results&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;constituentsAt(self,&nbsp;index):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Return&nbsp;a&nbsp;list&nbsp;of&nbsp;constituents&nbsp;at&nbsp;index."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;filter(self.<strong>constituentMaps</strong>[index].values())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;longestDisjointConstituents(self,&nbsp;categories=None):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Return&nbsp;a&nbsp;sequence&nbsp;of&nbsp;disjoint&nbsp;constituents&nbsp;such&nbsp;that&nbsp;each&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituent&nbsp;is&nbsp;one&nbsp;of&nbsp;the&nbsp;longest&nbsp;constituents&nbsp;at&nbsp;its&nbsp;index&nbsp;position.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;algorithm&nbsp;is&nbsp;myopic&nbsp;and&nbsp;locally&nbsp;greedy:&nbsp;it&nbsp;won't&nbsp;choose&nbsp;a&nbsp;shorter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituent&nbsp;in&nbsp;order&nbsp;to&nbsp;get&nbsp;the&nbsp;whole&nbsp;sequence&nbsp;to&nbsp;come&nbsp;out&nbsp;longer,&nbsp;and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;won't&nbsp;even&nbsp;choose&nbsp;between&nbsp;two&nbsp;constituents&nbsp;of&nbsp;equal&nbsp;length&nbsp;in&nbsp;order&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;get&nbsp;a&nbsp;longer&nbsp;overall&nbsp;sequence."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;index&nbsp;&lt;&nbsp;len(self.<strong>constituentMaps</strong>):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituents&nbsp;=&nbsp;constituentsAt(index)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;categories:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituents&nbsp;=&nbsp;filter(lambda&nbsp;c,cats=categories:c.category&nbsp;in&nbsp;cats,&nbsp;constituents)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;constituents:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituents.sort(lambda&nbsp;a,&nbsp;b:-cmp(a.end,&nbsp;b.end))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best&nbsp;=&nbsp;constituents[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results.append(best)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;=&nbsp;best.end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;=&nbsp;index&nbsp;+&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;results&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Chart&nbsp;manipulation&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;addConstituent(self,&nbsp;constituent,&nbsp;start,&nbsp;end):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.<strong>TRACE</strong>&nbsp;or&nbsp;self.<strong>TRACE_CONSTITUENTS</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;'adding',&nbsp;constituent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.<strong>firstConstituentsOnly</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;constituent.category,&nbsp;start,&nbsp;end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.<strong>constituentMaps</strong>[start].get(key):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>constituentMaps</strong>[start][key]&nbsp;=&nbsp;constituent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(automaton,&nbsp;state,&nbsp;left,&nbsp;right,&nbsp;children)&nbsp;in&nbsp;self.<strong>edges</strong>[start]:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;right&nbsp;==&nbsp;start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;successors&nbsp;=&nbsp;automaton.nextStates(state,&nbsp;constituent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;successors&nbsp;and&nbsp;self.<strong>TRACE_MATCHES</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;'\tmatched:'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;'\t\t',&nbsp;automaton.atStateString(state),&nbsp;'-&gt;'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;self.<strong>TRACE</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;successors:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;'\tmatched:&nbsp;\n\t\t%s&nbsp;-&gt;&nbsp;%s'&nbsp;%&nbsp;(automaton.atStateString(state),&nbsp;successors)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;automaton.atStateString(state)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;'\tdidn\'t&nbsp;match:&nbsp;\n\t\t%s'&nbsp;%&nbsp;(automaton.atStateString(state))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;successor&nbsp;in&nbsp;successors:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.<strong>TRACE_MATCHES</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;'\t\t',&nbsp;automaton.atStateString(successor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addEdge(automaton,&nbsp;successor,&nbsp;left,&nbsp;end,&nbsp;children&nbsp;+&nbsp;[constituent])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;addEdge(self,&nbsp;automaton,&nbsp;state,&nbsp;start,&nbsp;end,&nbsp;children):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;automaton.stateMatchesConstituents(state):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;=&nbsp;automaton,&nbsp;state,&nbsp;start,&nbsp;end,&nbsp;children&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>edges</strong>[end].append(edge)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;category&nbsp;in&nbsp;automaton.getStateCategories(state):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituent&nbsp;=&nbsp;Constituent(category,&nbsp;children,&nbsp;start,&nbsp;end)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituent.source&nbsp;=&nbsp;automaton&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;AttributeError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addConstituent(constituent,&nbsp;start,&nbsp;end)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;end&nbsp;&lt;&nbsp;len(self.<strong>tokens</strong>):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token&nbsp;=&nbsp;self.<strong>tokens</strong>[end]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constituents&nbsp;=&nbsp;self.<strong>constituentMaps</strong>[end].values()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;successor&nbsp;in&nbsp;automaton.nextStates(state,&nbsp;token):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addEdge(automaton,&nbsp;successor,&nbsp;start,&nbsp;end&nbsp;+&nbsp;1,&nbsp;children&nbsp;+&nbsp;[token])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;constituent&nbsp;in&nbsp;constituents:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;successor&nbsp;in&nbsp;automaton.nextStates(state,&nbsp;constituent):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addEdge(automaton,&nbsp;successor,&nbsp;start,&nbsp;constituent.end,&nbsp;children&nbsp;+&nbsp;[constituent])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Presentation&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;toDotString(self,&nbsp;includeActiveEdges=0):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Returns&nbsp;a&nbsp;string&nbsp;that&nbsp;can&nbsp;be&nbsp;printed&nbsp;by&nbsp;the&nbsp;DOT&nbsp;tool&nbsp;at&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</a>&nbsp;."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.append('digraph&nbsp;finite_state_machine&nbsp;{');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.append('\t0&nbsp;[style&nbsp;=&nbsp;bold];'&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.append('\tnode&nbsp;[shape&nbsp;=&nbsp;doublecircle];&nbsp;'&nbsp;+&nbsp;`self.<strong>finalIndex</strong>`&nbsp;+&nbsp;';'&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.append('\tnode&nbsp;[shape&nbsp;=&nbsp;circle];');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.append('\trankdir=LR;');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;includeActiveEdges:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;edges&nbsp;in&nbsp;self.<strong>edges</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(automaton,&nbsp;state,&nbsp;start,&nbsp;end,&nbsp;children)&nbsp;in&nbsp;edges:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label&nbsp;=&nbsp;string.replace(automaton.atStateString(state,&nbsp;wrap=20),&nbsp;'\n',&nbsp;'\\n')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.append('\t%s&nbsp;-&gt;&nbsp;%s&nbsp;[style=dotted,label="%s"];'&nbsp;%&nbsp;(start,&nbsp;end,&nbsp;label)&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;constituents&nbsp;in&nbsp;self.<strong>constituentMaps</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items&nbsp;=&nbsp;map(lambda&nbsp;c:(c.start,&nbsp;c.end,&nbsp;c),&nbsp;constituents.values())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.sort()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;item&nbsp;in&nbsp;items:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.append('\t%s&nbsp;-&gt;&nbsp;%s&nbsp;[label="%s"];'&nbsp;%&nbsp;item)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.append('}');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;string.join(output,&nbsp;'\n')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;view(self,&nbsp;includeActiveEdges=1):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSA.view(toDotString(includeActiveEdges=includeActiveEdges))##&nbsp;Chart&nbsp;classes#class&nbsp;Constituent:&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;category,&nbsp;children,&nbsp;start,&nbsp;end):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>category</strong>&nbsp;=&nbsp;category&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>children</strong>&nbsp;=&nbsp;children&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>start</strong>&nbsp;=&nbsp;start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>end</strong>&nbsp;=&nbsp;end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;leaves(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.<strong>children</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leaves&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;child&nbsp;in&nbsp;self.<strong>children</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;hasattr(child,&nbsp;'leaves'):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leaves.extend(child.leaves())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leaves.append(child)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;leaves&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[self]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__repr__(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.<strong>children</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;tokenStr(token):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(hasattr(token,&nbsp;'token')&nbsp;and&nbsp;str(token.token))&nbsp;or&nbsp;str(token)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;1:&nbsp;#flatten&nbsp;the&nbsp;printed&nbsp;representation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.<strong>category</strong>&nbsp;+&nbsp;'['&nbsp;+&nbsp;string.join(map(tokenStr,&nbsp;leaves()))&nbsp;+&nbsp;']'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.<strong>category</strong>&nbsp;+&nbsp;'['&nbsp;+&nbsp;string.join(map(str,&nbsp;self.<strong>children</strong>&nbsp;or&nbsp;[]),&nbsp;'&nbsp;')&nbsp;+&nbsp;']'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.<strong>category</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;length(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.<strong>end</strong>&nbsp;-&nbsp;self.<strong>start</strong>##&nbsp;Class&nbsp;CategorizingAutomaton#class&nbsp;CategorizingAutomaton(FSA.FSA):&nbsp;&nbsp;&nbsp;&nbsp;"""A&nbsp;categorizing&nbsp;automaton&nbsp;is&nbsp;a&nbsp;finite-state&nbsp;automaton&nbsp;that&nbsp;additionally&nbsp;&nbsp;&nbsp;&nbsp;maps&nbsp;each&nbsp;final&nbsp;state&nbsp;into&nbsp;a&nbsp;set&nbsp;of&nbsp;categories.&nbsp;A&nbsp;categorizing&nbsp;automataon&nbsp;&nbsp;&nbsp;&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;simultaneously&nbsp;recognize&nbsp;and&nbsp;categorize&nbsp;sequences&nbsp;according&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;a&nbsp;number&nbsp;of&nbsp;languages."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(*args,&nbsp;**keys):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply(FSA.FSA.__init__,&nbsp;args,&nbsp;keys)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self&nbsp;=&nbsp;args[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setStateCategoriesMapping({})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;coerce(self,&nbsp;klass):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coercion&nbsp;=&nbsp;FSA.FSA.coerce(self,&nbsp;klass)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coercion.setStateCategoriesMapping(getStateCategoriesMapping())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;coercion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Predicates&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;isCategorizingAutomaton&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;State&nbsp;categories&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;categories(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Return&nbsp;a&nbsp;list&nbsp;of&nbsp;categories&nbsp;that&nbsp;this&nbsp;automaton&nbsp;will&nbsp;categorize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;into."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;categories&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;set&nbsp;in&nbsp;getStateCategoriesMapping().values():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;category&nbsp;in&nbsp;set:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;category&nbsp;not&nbsp;in&nbsp;categories:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;categories.append(category)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;categories&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;getStateCategories(self,&nbsp;state):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.<strong>stateCategories</strong>[state]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;addStateCategory(self,&nbsp;state,&nbsp;category):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;categories&nbsp;=&nbsp;self.<strong>stateCategories</strong>[state]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;category&nbsp;not&nbsp;in&nbsp;categories:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>stateCategories</strong>[state]&nbsp;=&nbsp;categories&nbsp;+&nbsp;[category]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;getStateCategoriesMapping(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapping&nbsp;=&nbsp;{}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;state&nbsp;in&nbsp;self.<strong>states</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapping[state]&nbsp;=&nbsp;getStateCategories(state)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;mapping&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;setStateCategoriesMapping(self,&nbsp;mapping):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>stateCategories</strong>&nbsp;=&nbsp;makeStateTable([])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;state,&nbsp;categories&nbsp;in&nbsp;mapping.items():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>stateCategories</strong>[state]&nbsp;=&nbsp;categories&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;setFinalCategory(self,&nbsp;category):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Set&nbsp;all&nbsp;the&nbsp;final&nbsp;states&nbsp;to&nbsp;categorize&nbsp;to&nbsp;this&nbsp;category."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>stateCategories</strong>&nbsp;=&nbsp;makeStateTable([])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;state&nbsp;in&nbsp;self.<strong>finalStates</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addStateCategory(state,&nbsp;category)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Accessors&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;computeStateMatchesConstituents(self,&nbsp;state):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;stateMatchesConstituents(self,&nbsp;state):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isConstituentTestMap&nbsp;=&nbsp;self.<strong>isConstituentTestMap</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;AttributeError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isConstituentTestMap&nbsp;=&nbsp;[None]&nbsp;*&nbsp;(reduce(max,&nbsp;self.<strong>states</strong>)&nbsp;+&nbsp;1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;state&nbsp;in&nbsp;self.<strong>states</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isConstituentTestMap[state]&nbsp;=&nbsp;computeStateMatchesConstituents(state)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>isConstituentTestMap</strong>&nbsp;=&nbsp;isConstituentTestMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;isConstituentTestMap[state]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Presentation&nbsp;template&nbsp;overrides&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;additionalTransitionInfoString(self,&nbsp;transition):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;FSA.FSA.additionalTransitionInfoString(self,&nbsp;transition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;categories&nbsp;=&nbsp;getStateCategories(transition[1])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;categories:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;(result&nbsp;and&nbsp;result&nbsp;+&nbsp;'&nbsp;'&nbsp;or&nbsp;'')&nbsp;+&nbsp;`categories`#string.join(map(str,&nbsp;categories),&nbsp;',&nbsp;')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;stateLabelString(self,&nbsp;state):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;overrides&nbsp;the&nbsp;method&nbsp;in&nbsp;FSA,&nbsp;to&nbsp;include&nbsp;categorizing&nbsp;states&nbsp;in&nbsp;dot&nbsp;diagrams&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;categoriesFor(state):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;`state`&nbsp;+&nbsp;'\n'&nbsp;+&nbsp;string.join(map(str,&nbsp;categoriesFor(state)),&nbsp;',&nbsp;')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;atStateString(self,&nbsp;state,&nbsp;wrap=None):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;REUtils&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;REUtils.decompileRE(self,&nbsp;dottedStates=[state],&nbsp;wrap=wrap,&nbsp;sep=tokenSeparator())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ImportError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;"%s&nbsp;@&nbsp;%s"&nbsp;%&nbsp;(self,&nbsp;state)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(categories())&nbsp;==&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;'%s&nbsp;=&gt;&nbsp;%s'&nbsp;%&nbsp;(categories()[0],&nbsp;str)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;tokenSeparator(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;'&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Conversion&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;toFSA(self,&nbsp;labelConstructor=lambda&nbsp;s:'=&gt;'&nbsp;+&nbsp;s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Return&nbsp;an&nbsp;FSA&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;categorizing&nbsp;automaton&nbsp;that&nbsp;is&nbsp;the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argument,&nbsp;except&nbsp;that&nbsp;final&nbsp;state&nbsp;categories&nbsp;have&nbsp;been&nbsp;replaced&nbsp;by&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transitions&nbsp;labeled&nbsp;with&nbsp;a&nbsp;transformation&nbsp;of&nbsp;those&nbsp;categories."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;states,&nbsp;alphabet,&nbsp;transitions,&nbsp;initial,&nbsp;finals&nbsp;=&nbsp;tuple()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newFinal&nbsp;=&nbsp;nextAvailableState()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transitions&nbsp;=&nbsp;transitions[:]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;state,&nbsp;categories&nbsp;in&nbsp;getStateCategoriesMapping().items():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;category&nbsp;in&nbsp;categories:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transitions.append((state,&nbsp;newFinal,&nbsp;labelConstructor(category)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;copy(states&nbsp;+&nbsp;[newFinal],&nbsp;alphabet,&nbsp;transitions,&nbsp;initial,&nbsp;[newFinal])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Decision&nbsp;Functions&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;buildDecisionTree(self,&nbsp;pairs):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pairs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test,&nbsp;state&nbsp;=&nbsp;pairs[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;test.isUnconditional():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(None,&nbsp;state,&nbsp;state)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;term&nbsp;=&nbsp;test.terms()[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complement&nbsp;=&nbsp;term.complement()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;positives,&nbsp;negatives&nbsp;=&nbsp;[],&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;test,&nbsp;state&nbsp;in&nbsp;pairs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;term&nbsp;in&nbsp;test.terms():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;positives.append((test.build(filter(lambda&nbsp;x,&nbsp;term=term:x&nbsp;!=&nbsp;term,&nbsp;test.terms())),&nbsp;state))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;negatives.append((test.build(filter(lambda&nbsp;x,&nbsp;term=complement:x&nbsp;!=&nbsp;term,&nbsp;test.terms())),&nbsp;state))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(term,&nbsp;buildDecisionTree(positives),&nbsp;buildDecisionTree(negatives))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;buildDecisionTreeDecider(self,&nbsp;pairs):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;decisionTreeDecider(constituent,&nbsp;tree=buildDecisionTree(pairs)):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;tree:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test,&nbsp;positive,&nbsp;negative&nbsp;=&nbsp;tree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;test:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;test.matches(constituent):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree&nbsp;=&nbsp;positive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree&nbsp;=&nbsp;negative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;positive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;decisionTreeDecider&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;buildSerialDecider(self,&nbsp;pairs):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pairs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;serialDecider(constituent,&nbsp;pairs=pairs):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;test,&nbsp;state&nbsp;in&nbsp;pairs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;test.matches(constituent):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;serialDecider&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;lambda&nbsp;constituent:None&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;buildDecisionFunctions(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;getattr(self,&nbsp;'_isDeterminized',&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decisionFunctions&nbsp;=&nbsp;[None]&nbsp;*&nbsp;(reduce(max,&nbsp;self.<strong>states</strong>)&nbsp;+&nbsp;1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;state&nbsp;in&nbsp;self.<strong>states</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decisionFunctions[state]&nbsp;=&nbsp;buildDecisionFunction(state)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>decisionFunctions</strong>&nbsp;=&nbsp;decisionFunctions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>nextState</strong>&nbsp;=&nbsp;self.<strong>nextStateUsingDecisionFunctions</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>nextStates</strong>&nbsp;=&nbsp;self.<strong>nextStatesUsingDecisionFunctions</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;nextStateUsingDecisionFunctions(self,&nbsp;state,&nbsp;input):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;successor&nbsp;=&nbsp;self.<strong>decisionFunctions</strong>[state](input)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;successor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;nextStatesUsingDecisionFunctions(self,&nbsp;state,&nbsp;input):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;successor&nbsp;=&nbsp;self.<strong>decisionFunctions</strong>[state](input)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;successor&nbsp;is&nbsp;not&nbsp;None&nbsp;and&nbsp;[successor]&nbsp;or&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Accepting&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;labelMatches(self,&nbsp;label,&nbsp;constituent):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Override&nbsp;the&nbsp;implementation&nbsp;in&nbsp;FSA,&nbsp;so&nbsp;that&nbsp;strings&nbsp;can&nbsp;be&nbsp;used&nbsp;as&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels&nbsp;that&nbsp;match&nbsp;the&nbsp;constituent's&nbsp;categories."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;type(label)&nbsp;==&nbsp;StringType:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;label&nbsp;==&nbsp;constituent&nbsp;or&nbsp;hasattr(constituent,&nbsp;'category')&nbsp;and&nbsp;label&nbsp;==&nbsp;constituent.category&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FSA.FSA.labelMatches(self,&nbsp;label,&nbsp;constituent)##&nbsp;Grammar&nbsp;compilation#def&nbsp;compileRule(rule,&nbsp;defaultCategory='S'):&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;getattr(rule,&nbsp;'isCategorizingAutomaton',&nbsp;0):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automaton&nbsp;=&nbsp;rule&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;getattr(rule,&nbsp;'isFSA',&nbsp;0):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automaton&nbsp;=&nbsp;rule.coerce(CategorizingAutomaton)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automaton.setFinalCategory(defaultCategory)&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;type(rule)&nbsp;==&nbsp;TupleType:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lhs,&nbsp;rhs&nbsp;=&nbsp;rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;type(rhs)&nbsp;==&nbsp;ListType:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rhs&nbsp;=&nbsp;FSA.sequence(rhs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automaton&nbsp;=&nbsp;rhs.coerce(CategorizingAutomaton)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automaton.setFinalCategory(lhs)&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;'rule&nbsp;must&nbsp;be&nbsp;a&nbsp;(lhs,&nbsp;automaton)&nbsp;or&nbsp;an&nbsp;automaton'&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;automatondef&nbsp;compileRules(rules,&nbsp;optimize=0,&nbsp;labelConstructor=None):&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Rules&nbsp;is&nbsp;either&nbsp;a&nbsp;list&nbsp;of&nbsp;CategorizingFSAs&nbsp;or&nbsp;(lhs,&nbsp;rhs)&nbsp;pairs,&nbsp;where&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;each&nbsp;rhs&nbsp;is&nbsp;either&nbsp;a&nbsp;list&nbsp;or&nbsp;an&nbsp;automaton.&nbsp;Turn&nbsp;each&nbsp;pair&nbsp;ino&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;CategorizingAutomaton&nbsp;by&nbsp;coercing&nbsp;it&nbsp;and&nbsp;setting&nbsp;the&nbsp;categories&nbsp;of&nbsp;its&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;final&nbsp;states&nbsp;to&nbsp;the&nbsp;lhs.&nbsp;&nbsp;&nbsp;&nbsp;automata&nbsp;=&nbsp;map(compileRule,&nbsp;rules)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;optimize:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automata&nbsp;=&nbsp;[combineRules(rules)]&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;automatadef&nbsp;combineRules(rules,&nbsp;labelConstructor=None):&nbsp;&nbsp;&nbsp;&nbsp;"""Create&nbsp;a&nbsp;categorizing&nbsp;automaton&nbsp;from&nbsp;a&nbsp;list&nbsp;of&nbsp;rules.&nbsp;Each&nbsp;rules&nbsp;is&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;tuple&nbsp;(lhs,&nbsp;rhs),&nbsp;where&nbsp;lhs&nbsp;is&nbsp;the&nbsp;category&nbsp;for&nbsp;sequences&nbsp;recognized&nbsp;by&nbsp;&nbsp;&nbsp;&nbsp;rhs,&nbsp;which&nbsp;is&nbsp;an&nbsp;automaton.&nbsp;lhsLabelConstructor&nbsp;is&nbsp;an&nbsp;expression&nbsp;that&nbsp;&nbsp;&nbsp;&nbsp;converts&nbsp;a&nbsp;category&nbsp;into&nbsp;a&nbsp;label&nbsp;that&nbsp;can&nbsp;be&nbsp;intersected&nbsp;with&nbsp;the&nbsp;labels&nbsp;in&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;rule&nbsp;automata&nbsp;(the&nbsp;intersection&nbsp;of&nbsp;a&nbsp;category&nbsp;label&nbsp;with&nbsp;any&nbsp;rhs&nbsp;&nbsp;&nbsp;&nbsp;automaton&nbsp;label&nbsp;or&nbsp;with&nbsp;any&nbsp;other&nbsp;category&nbsp;label&nbsp;should&nbsp;be&nbsp;None);&nbsp;it&nbsp;&nbsp;&nbsp;&nbsp;defaults&nbsp;to&nbsp;a&nbsp;function&nbsp;that&nbsp;turns&nbsp;the&nbsp;category&nbsp;'C'&nbsp;into&nbsp;'=&gt;C'."""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lhsMap&nbsp;=&nbsp;{}&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;construct(rule,&nbsp;labelConstructor=labelConstructor&nbsp;or&nbsp;(lambda&nbsp;s:'=&gt;'&nbsp;+&nbsp;s),&nbsp;lhsMap=lhsMap):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automaton&nbsp;=&nbsp;compileRule(rule)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;category&nbsp;in&nbsp;automaton.categories():&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lhsMap[labelConstructor(category)]&nbsp;=&nbsp;category&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;automaton.toFSA(labelConstructor=labelConstructor)&nbsp;&nbsp;&nbsp;&nbsp;automata&nbsp;=&nbsp;map(construct&nbsp;,&nbsp;rules)&nbsp;&nbsp;&nbsp;&nbsp;fsa&nbsp;=&nbsp;apply(FSA.union,&nbsp;automata).minimized()&nbsp;&nbsp;&nbsp;&nbsp;states0,&nbsp;alpha,&nbsp;transitions0,&nbsp;initial,&nbsp;finals0&nbsp;=&nbsp;fsa.tuple()&nbsp;&nbsp;&nbsp;&nbsp;transitions&nbsp;=&nbsp;filter(lambda&nbsp;(s0,s1,label),&nbsp;f=lhsMap.get:&nbsp;not&nbsp;f(label),&nbsp;transitions0)&nbsp;&nbsp;&nbsp;&nbsp;finalTransitions=&nbsp;filter(lambda&nbsp;(s0,s1,label),&nbsp;f=lhsMap.get:&nbsp;f(label),&nbsp;transitions0)&nbsp;&nbsp;&nbsp;&nbsp;states&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;s0,&nbsp;s1,&nbsp;_&nbsp;in&nbsp;transitions:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;s0&nbsp;not&nbsp;in&nbsp;states:&nbsp;states.append(s0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;s1&nbsp;not&nbsp;in&nbsp;states:&nbsp;states.append(s1)&nbsp;&nbsp;&nbsp;&nbsp;finals&nbsp;=&nbsp;map(lambda&nbsp;(s0,s1,_):&nbsp;s0,&nbsp;finalTransitions)&nbsp;&nbsp;&nbsp;&nbsp;fsa&nbsp;=&nbsp;automata[0].copy(states,&nbsp;alpha,&nbsp;transitions,&nbsp;initial,&nbsp;finals)&nbsp;&nbsp;&nbsp;&nbsp;fsa._isDeterminized&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;state,&nbsp;_,&nbsp;label&nbsp;in&nbsp;finalTransitions:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsa.addStateCategory(state,&nbsp;lhsMap[label])&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fsa"""RULES&nbsp;=&nbsp;map(lambda&nbsp;(lhs,&nbsp;rhs):(lhs,&nbsp;FSA.compileRE(rhs,&nbsp;multichar=1)),&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('S',&nbsp;'NP&nbsp;VP'),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('NP',&nbsp;"det?&nbsp;adj*&nbsp;noun+"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('NP',&nbsp;'noun&nbsp;of&nbsp;noun'),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('VP',&nbsp;'verb&nbsp;NP')])parser&nbsp;=&nbsp;ChartParser(compileRules(RULES))print&nbsp;parser.parseString('noun&nbsp;verb&nbsp;noun',&nbsp;multichar=1).constituents(complete=1)parser&nbsp;=&nbsp;ChartParser(compileRules(RULES,&nbsp;optimize=1))print&nbsp;parser.parseString('noun&nbsp;verb&nbsp;noun',&nbsp;multichar=1).constituents(complete=1)print&nbsp;parser.parseString('det&nbsp;adj&nbsp;noun&nbsp;noun&nbsp;verb&nbsp;adj&nbsp;noun',&nbsp;multichar=1).constituents(complete=1)print&nbsp;parser.toDotString()print&nbsp;parser.toDotString(includeActiveEdges=1)p.view()"""</tt></p>

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;&nbsp;</td>
<td width="100%"><strong>__file__</strong> = r'.\FSChartParser.py'<br>
<strong>__name__</strong> = 'FSChartParser'</td></tr></table>
</body></html>